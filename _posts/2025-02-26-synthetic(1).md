---
title: >-
    [프로젝트] Synthetic dataset 생성 도구 제작(1)
author: csm
date: 2025-02-26 14:10:00 +0900
categories: [Research, Network Science]
tags: [project]
description: 단일세포 및 공간전사체에 대한 합성데이터셋을 생성하는 프로젝트
---

## 개요
---
- Synthetic dataset을 생성하는 도구 출판이 목적
- Network science 분야와 연결

## Nezzle로 시각화
---
- input이 배열(`layers`, 계층구조)로 들어갈 때 각 종류의 피드백이 네트워크 형성 방식에 따라 결정됨
- 각 노드는 index(`row_idx`, `col_idx}`)로 구분
- 각 피드백은 index(`src.iden`, `tar.iden`)으로 구분
- 각 피드백은 랜덤한 갯수로 추가
- code
    ```python
    from qtpy.QtCore import Qt
    from qtpy.QtCore import QPointF
    from qtpy.QtGui import QColor

    from nezzle.graphics import EllipseNode
    from nezzle.graphics import StraightEdge
    from nezzle.graphics import CurvedEdge
    from nezzle.graphics import Triangle
    from nezzle.graphics import Hammer
    from nezzle.graphics import Network
    from nezzle.graphics import TextLabel

    import random

    def add_node(net, iden, x, y, row_idx, col_idx):
        node = EllipseNode(iden, 40, 40, pos=QPointF(x, y))

        node["FILL_COLOR"] = Qt.yellow
        node["BORDER_COLOR"] = Qt.black
        node["BORDER_WIDTH"] = 4

        node.row_idx = row_idx
        node.col_idx = col_idx
        
        label_text = f"{col_idx}-{row_idx}"
        label = TextLabel(node, label_text)
        label["FONT_SIZE"] = 20
        label["TEXT_COLOR"] = Qt.black
        label.align()
        
        net.add_node(node)
        return node


    def create_edges(net, entity, col_idx):
        if col_idx < 0 or col_idx >= len(entity):
            return
        
        for i in range(len(entity[col_idx]) - 1):
            src = entity[col_idx][i]
            trg = entity[col_idx][i + 1]
            
            head = Triangle(width=15, height=10, offset=4)
            iden = "%s-%s" % (src.iden, trg.iden)
            edge = StraightEdge(iden, src, trg, width=4, head=head)
            edge["FILL_COLOR"] = Qt.black
            net.add_edge(edge)


    def add_feedback_edges(net, entity, n, f_type="feedbackloop", d_type="dtu", p_type="positive"):
        head_types = {
            "positive": Triangle(width=15, height=10, offset=4),
            "negative": Hammer(width=30, height=5, offset=4)
        }
        head = head_types.get(p_type, Triangle(width=15, height=10, offset=4))
        
        created_edges = 0
        
        while created_edges < n:
            if f_type == "feedbackloop":
                col = random.choice(entity)
                src, trg = random.sample(col, 2)
            elif f_type == "crosstalk":
                src_col, trg_col = random.sample(entity, 2)
                src = random.choice(src_col)
                trg = random.choice(trg_col)

            if d_type == "same":
                if src.row_idx != trg.row_idx:
                    continue
            elif d_type == "dtu":
                if src.row_idx < trg.row_idx:
                    src, trg = trg, src
            elif d_type == "utd":
                if src.row_idx > trg.row_idx:
                    src, trg = trg, src

            iden = f"{src.iden}-{trg.iden}"
            edge = CurvedEdge(iden, src, trg, width=4, head=head)
            edge["CP_POS_X"] = 100
            edge["CP_POS_Y"] = 100
            edge["FILL_COLOR"] = QColor(255, 0, 0, 150) if p_type == "negative" else QColor(0, 255, 0, 150)
            net.add_edge(edge)
            created_edges += 1


    def create_network(layers, r=40, vs=150, hs=150):
        net = Network("Network")
        entity = []
        
        for col_idx, num_nodes in enumerate(layers):
            x_pos = col_idx * (r + hs)
            col_nodes = []

            for row_idx in range(num_nodes):
                y_pos = row_idx * (r + vs)
                iden = "%s-%s" % (col_idx, row_idx)
                node = add_node(net, iden, x_pos, y_pos, row_idx, col_idx)
                col_nodes.append(node)

            entity.append(col_nodes)

        return net, entity


    def update(nav, net):
        layers = [6, 4, 7, 5, 8, 3, 6]
        net, entity = create_network(layers)

        for col_idx in range(len(layers)):
            create_edges(net, entity, col_idx)
        
        feedback_types = ["feedbackloop", "crosstalk"]
        polarity_types = ["positive", "negative"]
        
        num_edges = random.randint(20, 50)

        for _ in range(num_edges):
            f_type = random.choice(feedback_types)

            if f_type == "feedbackloop":
                direction_types = ["utd", "dtu"]
            else:
                direction_types = ["utd", "dtu", "same"]

            d_type = random.choice(direction_types)
            p_type = random.choice(polarity_types)

            add_feedback_edges(net, entity, 1, f_type=f_type, d_type=d_type, p_type=p_type)
            
        nav.append_item(net)
    ```
- img1  

    <img src="https://github.com/user-attachments/assets/a83ef764-910f-467a-b8c6-91fa69d7b514" alt="1" width="70%" height="70%"/>  

- img2  

    <img src="https://github.com/user-attachments/assets/acee0ae1-e776-4e3f-97f9-bcaf41327a19" alt="2" width="70%" height="70%"/>  


## NetworkX(+numpy)로 구현
---
- 구조는 네트워크를 통해 결정: 노드와 피드백의 갯수가 네트워크를 따름
- NetworkX 패키지의 graph generators 사용
    - `barabasi_albert_graph`
        - 스케일-프리 네트워크 생성
        - 기존 노드들의 차수에 비례하여 새로운 노드가 연결될 확률 증가 ⟶ '허브' 노드 형성
    - `powerlaw_cluster_graph` 
        - Power-law 분포를 따르는 노드들이 클러스터링 된 구조를 갖는 네트워크를 형성
        - `p`: 클러스터링 확률
- 생성된 피드백의 종류와 갯수 출력
- code
    ```
    ```